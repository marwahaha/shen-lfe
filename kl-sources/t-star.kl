"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3643 V3644) (let Curry (shen.curry V3643) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3644)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3646) (cond ((and (cons? V3646) (shen.special? (hd V3646))) (cons (hd V3646) (map (lambda Y (shen.curry Y)) (tl V3646)))) ((and (cons? V3646) (and (cons? (tl V3646)) (shen.extraspecial? (hd V3646)))) V3646) ((and (cons? V3646) (and (= type (hd V3646)) (and (cons? (tl V3646)) (and (cons? (tl (tl V3646))) (= () (tl (tl (tl V3646)))))))) (cons type (cons (shen.curry (hd (tl V3646))) (tl (tl V3646))))) ((and (cons? V3646) (and (cons? (tl V3646)) (cons? (tl (tl V3646))))) (shen.curry (cons (cons (hd V3646) (cons (hd (tl V3646)) ())) (tl (tl V3646))))) ((and (cons? V3646) (and (cons? (tl V3646)) (= () (tl (tl V3646))))) (cons (shen.curry (hd V3646)) (cons (shen.curry (hd (tl V3646))) ()))) (true V3646)))

(defun shen.special? (V3648) (element? V3648 (value shen.*special*)))

(defun shen.extraspecial? (V3650) (element? V3650 (value shen.*extraspecial*)))

(defun shen.t* (V3655 V3656 V3657 V3658) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3657) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3657 (freeze (bind Error (shen.errormaxinfs) V3657 V3658))))) (if (= Case false) (let Case (let V3635 (shen.lazyderef V3655 V3657) (if (= fail V3635) (do (shen.incinfs) (cut Throwcontrol V3657 (freeze (shen.prolog-failure V3657 V3658)))) false)) (if (= Case false) (let Case (let V3636 (shen.lazyderef V3655 V3657) (if (cons? V3636) (let X (hd V3636) (let V3637 (shen.lazyderef (tl V3636) V3657) (if (cons? V3637) (let V3638 (shen.lazyderef (hd V3637) V3657) (if (= : V3638) (let V3639 (shen.lazyderef (tl V3637) V3657) (if (cons? V3639) (let A (hd V3639) (let V3640 (shen.lazyderef (tl V3639) V3657) (if (= () V3640) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3657 (freeze (cut Throwcontrol V3657 (freeze (shen.th* X A V3656 V3657 V3658)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3657) (do (shen.incinfs) (shen.show V3655 V3656 V3657 (freeze (bind Datatypes (value shen.*datatypes*) V3657 (freeze (shen.udefs* V3655 V3656 Datatypes V3657 V3658))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3664) (cond ((= + V3664) (set shen.*shen-type-theory-enabled?* true)) ((= - V3664) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3675 V3676) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3682 V3683 V3684 V3685 V3686) (let Case (let V3631 (shen.lazyderef V3684 V3685) (if (cons? V3631) (let D (hd V3631) (do (shen.incinfs) (call (cons D (cons V3682 (cons V3683 ()))) V3685 V3686))) false)) (if (= Case false) (let V3632 (shen.lazyderef V3684 V3685) (if (cons? V3632) (let Ds (tl V3632) (do (shen.incinfs) (shen.udefs* V3682 V3683 Ds V3685 V3686))) false)) Case)))

(defun shen.th* (V3692 V3693 V3694 V3695 V3696) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3692 (cons : (cons V3693 ()))) V3694 V3695 (freeze (fwhen false V3695 V3696)))) (if (= Case false) (let Case (let F (shen.newpv V3695) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3692 V3695)) V3695 (freeze (bind F (shen.sigf (shen.lazyderef V3692 V3695)) V3695 (freeze (call (cons F (cons V3693 ())) V3695 V3696))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3692 V3693 V3695 V3696)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3692 V3693 V3694 V3695 V3696)) (if (= Case false) (let Case (let V3527 (shen.lazyderef V3692 V3695) (if (cons? V3527) (let F (hd V3527) (let V3528 (shen.lazyderef (tl V3527) V3695) (if (= () V3528) (do (shen.incinfs) (shen.th* F (cons --> (cons V3693 ())) V3694 V3695 V3696)) false))) false)) (if (= Case false) (let Case (let V3529 (shen.lazyderef V3692 V3695) (if (cons? V3529) (let F (hd V3529) (let V3530 (shen.lazyderef (tl V3529) V3695) (if (cons? V3530) (let X (hd V3530) (let V3531 (shen.lazyderef (tl V3530) V3695) (if (= () V3531) (let B (shen.newpv V3695) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3693 ()))) V3694 V3695 (freeze (shen.th* X B V3694 V3695 V3696))))) false))) false))) false)) (if (= Case false) (let Case (let V3532 (shen.lazyderef V3692 V3695) (if (cons? V3532) (let V3533 (shen.lazyderef (hd V3532) V3695) (if (= cons V3533) (let V3534 (shen.lazyderef (tl V3532) V3695) (if (cons? V3534) (let X (hd V3534) (let V3535 (shen.lazyderef (tl V3534) V3695) (if (cons? V3535) (let Y (hd V3535) (let V3536 (shen.lazyderef (tl V3535) V3695) (if (= () V3536) (let V3537 (shen.lazyderef V3693 V3695) (if (cons? V3537) (let V3538 (shen.lazyderef (hd V3537) V3695) (if (= list V3538) (let V3539 (shen.lazyderef (tl V3537) V3695) (if (cons? V3539) (let A (hd V3539) (let V3540 (shen.lazyderef (tl V3539) V3695) (if (= () V3540) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (if (shen.pvar? V3540) (do (shen.bindv V3540 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3540 V3695) Result))) false)))) (if (shen.pvar? V3539) (let A (shen.newpv V3695) (do (shen.bindv V3539 (cons A ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3539 V3695) Result)))) false))) (if (shen.pvar? V3538) (do (shen.bindv V3538 list V3695) (let Result (let V3541 (shen.lazyderef (tl V3537) V3695) (if (cons? V3541) (let A (hd V3541) (let V3542 (shen.lazyderef (tl V3541) V3695) (if (= () V3542) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (if (shen.pvar? V3542) (do (shen.bindv V3542 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3542 V3695) Result))) false)))) (if (shen.pvar? V3541) (let A (shen.newpv V3695) (do (shen.bindv V3541 (cons A ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3541 V3695) Result)))) false))) (do (shen.unbindv V3538 V3695) Result))) false))) (if (shen.pvar? V3537) (let A (shen.newpv V3695) (do (shen.bindv V3537 (cons list (cons A ())) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons list (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3537 V3695) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3543 (shen.lazyderef V3692 V3695) (if (cons? V3543) (let V3544 (shen.lazyderef (hd V3543) V3695) (if (= @p V3544) (let V3545 (shen.lazyderef (tl V3543) V3695) (if (cons? V3545) (let X (hd V3545) (let V3546 (shen.lazyderef (tl V3545) V3695) (if (cons? V3546) (let Y (hd V3546) (let V3547 (shen.lazyderef (tl V3546) V3695) (if (= () V3547) (let V3548 (shen.lazyderef V3693 V3695) (if (cons? V3548) (let A (hd V3548) (let V3549 (shen.lazyderef (tl V3548) V3695) (if (cons? V3549) (let V3550 (shen.lazyderef (hd V3549) V3695) (if (= * V3550) (let V3551 (shen.lazyderef (tl V3549) V3695) (if (cons? V3551) (let B (hd V3551) (let V3552 (shen.lazyderef (tl V3551) V3695) (if (= () V3552) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (if (shen.pvar? V3552) (do (shen.bindv V3552 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3552 V3695) Result))) false)))) (if (shen.pvar? V3551) (let B (shen.newpv V3695) (do (shen.bindv V3551 (cons B ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3551 V3695) Result)))) false))) (if (shen.pvar? V3550) (do (shen.bindv V3550 * V3695) (let Result (let V3553 (shen.lazyderef (tl V3549) V3695) (if (cons? V3553) (let B (hd V3553) (let V3554 (shen.lazyderef (tl V3553) V3695) (if (= () V3554) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (if (shen.pvar? V3554) (do (shen.bindv V3554 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3554 V3695) Result))) false)))) (if (shen.pvar? V3553) (let B (shen.newpv V3695) (do (shen.bindv V3553 (cons B ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3553 V3695) Result)))) false))) (do (shen.unbindv V3550 V3695) Result))) false))) (if (shen.pvar? V3549) (let B (shen.newpv V3695) (do (shen.bindv V3549 (cons * (cons B ())) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3549 V3695) Result)))) false)))) (if (shen.pvar? V3548) (let A (shen.newpv V3695) (let B (shen.newpv V3695) (do (shen.bindv V3548 (cons A (cons * (cons B ()))) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y B V3694 V3695 V3696)))) (do (shen.unbindv V3548 V3695) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3555 (shen.lazyderef V3692 V3695) (if (cons? V3555) (let V3556 (shen.lazyderef (hd V3555) V3695) (if (= @v V3556) (let V3557 (shen.lazyderef (tl V3555) V3695) (if (cons? V3557) (let X (hd V3557) (let V3558 (shen.lazyderef (tl V3557) V3695) (if (cons? V3558) (let Y (hd V3558) (let V3559 (shen.lazyderef (tl V3558) V3695) (if (= () V3559) (let V3560 (shen.lazyderef V3693 V3695) (if (cons? V3560) (let V3561 (shen.lazyderef (hd V3560) V3695) (if (= vector V3561) (let V3562 (shen.lazyderef (tl V3560) V3695) (if (cons? V3562) (let A (hd V3562) (let V3563 (shen.lazyderef (tl V3562) V3695) (if (= () V3563) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (if (shen.pvar? V3563) (do (shen.bindv V3563 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3563 V3695) Result))) false)))) (if (shen.pvar? V3562) (let A (shen.newpv V3695) (do (shen.bindv V3562 (cons A ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3562 V3695) Result)))) false))) (if (shen.pvar? V3561) (do (shen.bindv V3561 vector V3695) (let Result (let V3564 (shen.lazyderef (tl V3560) V3695) (if (cons? V3564) (let A (hd V3564) (let V3565 (shen.lazyderef (tl V3564) V3695) (if (= () V3565) (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (if (shen.pvar? V3565) (do (shen.bindv V3565 () V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3565 V3695) Result))) false)))) (if (shen.pvar? V3564) (let A (shen.newpv V3695) (do (shen.bindv V3564 (cons A ()) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3564 V3695) Result)))) false))) (do (shen.unbindv V3561 V3695) Result))) false))) (if (shen.pvar? V3560) (let A (shen.newpv V3695) (do (shen.bindv V3560 (cons vector (cons A ())) V3695) (let Result (do (shen.incinfs) (shen.th* X A V3694 V3695 (freeze (shen.th* Y (cons vector (cons A ())) V3694 V3695 V3696)))) (do (shen.unbindv V3560 V3695) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3566 (shen.lazyderef V3692 V3695) (if (cons? V3566) (let V3567 (shen.lazyderef (hd V3566) V3695) (if (= @s V3567) (let V3568 (shen.lazyderef (tl V3566) V3695) (if (cons? V3568) (let X (hd V3568) (let V3569 (shen.lazyderef (tl V3568) V3695) (if (cons? V3569) (let Y (hd V3569) (let V3570 (shen.lazyderef (tl V3569) V3695) (if (= () V3570) (let V3571 (shen.lazyderef V3693 V3695) (if (= string V3571) (do (shen.incinfs) (shen.th* X string V3694 V3695 (freeze (shen.th* Y string V3694 V3695 V3696)))) (if (shen.pvar? V3571) (do (shen.bindv V3571 string V3695) (let Result (do (shen.incinfs) (shen.th* X string V3694 V3695 (freeze (shen.th* Y string V3694 V3695 V3696)))) (do (shen.unbindv V3571 V3695) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3572 (shen.lazyderef V3692 V3695) (if (cons? V3572) (let V3573 (shen.lazyderef (hd V3572) V3695) (if (= lambda V3573) (let V3574 (shen.lazyderef (tl V3572) V3695) (if (cons? V3574) (let X (hd V3574) (let V3575 (shen.lazyderef (tl V3574) V3695) (if (cons? V3575) (let Y (hd V3575) (let V3576 (shen.lazyderef (tl V3575) V3695) (if (= () V3576) (let V3577 (shen.lazyderef V3693 V3695) (if (cons? V3577) (let A (hd V3577) (let V3578 (shen.lazyderef (tl V3577) V3695) (if (cons? V3578) (let V3579 (shen.lazyderef (hd V3578) V3695) (if (= --> V3579) (let V3580 (shen.lazyderef (tl V3578) V3695) (if (cons? V3580) (let B (hd V3580) (let V3581 (shen.lazyderef (tl V3580) V3695) (if (= () V3581) (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (if (shen.pvar? V3581) (do (shen.bindv V3581 () V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3581 V3695) Result))) false)))) (if (shen.pvar? V3580) (let B (shen.newpv V3695) (do (shen.bindv V3580 (cons B ()) V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3580 V3695) Result)))) false))) (if (shen.pvar? V3579) (do (shen.bindv V3579 --> V3695) (let Result (let V3582 (shen.lazyderef (tl V3578) V3695) (if (cons? V3582) (let B (hd V3582) (let V3583 (shen.lazyderef (tl V3582) V3695) (if (= () V3583) (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (if (shen.pvar? V3583) (do (shen.bindv V3583 () V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3583 V3695) Result))) false)))) (if (shen.pvar? V3582) (let B (shen.newpv V3695) (do (shen.bindv V3582 (cons B ()) V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3582 V3695) Result)))) false))) (do (shen.unbindv V3579 V3695) Result))) false))) (if (shen.pvar? V3578) (let B (shen.newpv V3695) (do (shen.bindv V3578 (cons --> (cons B ())) V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3578 V3695) Result)))) false)))) (if (shen.pvar? V3577) (let A (shen.newpv V3695) (let B (shen.newpv V3695) (do (shen.bindv V3577 (cons A (cons --> (cons B ()))) V3695) (let Result (let Z (shen.newpv V3695) (let X&& (shen.newpv V3695) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Y V3695)) V3695 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3694) V3695 V3696)))))))))) (do (shen.unbindv V3577 V3695) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3584 (shen.lazyderef V3692 V3695) (if (cons? V3584) (let V3585 (shen.lazyderef (hd V3584) V3695) (if (= let V3585) (let V3586 (shen.lazyderef (tl V3584) V3695) (if (cons? V3586) (let X (hd V3586) (let V3587 (shen.lazyderef (tl V3586) V3695) (if (cons? V3587) (let Y (hd V3587) (let V3588 (shen.lazyderef (tl V3587) V3695) (if (cons? V3588) (let Z (hd V3588) (let V3589 (shen.lazyderef (tl V3588) V3695) (if (= () V3589) (let W (shen.newpv V3695) (let X&& (shen.newpv V3695) (let B (shen.newpv V3695) (do (shen.incinfs) (shen.th* Y B V3694 V3695 (freeze (bind X&& (shen.placeholder) V3695 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3695) (shen.lazyderef X V3695) (shen.lazyderef Z V3695)) V3695 (freeze (shen.th* W V3693 (cons (cons X&& (cons : (cons B ()))) V3694) V3695 V3696))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3590 (shen.lazyderef V3692 V3695) (if (cons? V3590) (let V3591 (shen.lazyderef (hd V3590) V3695) (if (= open V3591) (let V3592 (shen.lazyderef (tl V3590) V3695) (if (cons? V3592) (let FileName (hd V3592) (let V3593 (shen.lazyderef (tl V3592) V3695) (if (cons? V3593) (let Direction3523 (hd V3593) (let V3594 (shen.lazyderef (tl V3593) V3695) (if (= () V3594) (let V3595 (shen.lazyderef V3693 V3695) (if (cons? V3595) (let V3596 (shen.lazyderef (hd V3595) V3695) (if (= stream V3596) (let V3597 (shen.lazyderef (tl V3595) V3695) (if (cons? V3597) (let Direction (hd V3597) (let V3598 (shen.lazyderef (tl V3597) V3695) (if (= () V3598) (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (if (shen.pvar? V3598) (do (shen.bindv V3598 () V3695) (let Result (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (do (shen.unbindv V3598 V3695) Result))) false)))) (if (shen.pvar? V3597) (let Direction (shen.newpv V3695) (do (shen.bindv V3597 (cons Direction ()) V3695) (let Result (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (do (shen.unbindv V3597 V3695) Result)))) false))) (if (shen.pvar? V3596) (do (shen.bindv V3596 stream V3695) (let Result (let V3599 (shen.lazyderef (tl V3595) V3695) (if (cons? V3599) (let Direction (hd V3599) (let V3600 (shen.lazyderef (tl V3599) V3695) (if (= () V3600) (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (if (shen.pvar? V3600) (do (shen.bindv V3600 () V3695) (let Result (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (do (shen.unbindv V3600 V3695) Result))) false)))) (if (shen.pvar? V3599) (let Direction (shen.newpv V3695) (do (shen.bindv V3599 (cons Direction ()) V3695) (let Result (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (do (shen.unbindv V3599 V3695) Result)))) false))) (do (shen.unbindv V3596 V3695) Result))) false))) (if (shen.pvar? V3595) (let Direction (shen.newpv V3695) (do (shen.bindv V3595 (cons stream (cons Direction ())) V3695) (let Result (do (shen.incinfs) (unify! Direction Direction3523 V3695 (freeze (cut Throwcontrol V3695 (freeze (fwhen (element? (shen.lazyderef Direction V3695) (cons in (cons out ()))) V3695 (freeze (shen.th* FileName string V3694 V3695 V3696)))))))) (do (shen.unbindv V3595 V3695) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3601 (shen.lazyderef V3692 V3695) (if (cons? V3601) (let V3602 (shen.lazyderef (hd V3601) V3695) (if (= type V3602) (let V3603 (shen.lazyderef (tl V3601) V3695) (if (cons? V3603) (let X (hd V3603) (let V3604 (shen.lazyderef (tl V3603) V3695) (if (cons? V3604) (let A (hd V3604) (let V3605 (shen.lazyderef (tl V3604) V3695) (if (= () V3605) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (unify A V3693 V3695 (freeze (shen.th* X A V3694 V3695 V3696)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3606 (shen.lazyderef V3692 V3695) (if (cons? V3606) (let V3607 (shen.lazyderef (hd V3606) V3695) (if (= input+ V3607) (let V3608 (shen.lazyderef (tl V3606) V3695) (if (cons? V3608) (let A (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3695) (if (cons? V3609) (let Stream (hd V3609) (let V3610 (shen.lazyderef (tl V3609) V3695) (if (= () V3610) (let C (shen.newpv V3695) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3695)) V3695 (freeze (unify V3693 C V3695 (freeze (shen.th* Stream (cons stream (cons in ())) V3694 V3695 V3696))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3611 (shen.lazyderef V3692 V3695) (if (cons? V3611) (let V3612 (shen.lazyderef (hd V3611) V3695) (if (= set V3612) (let V3613 (shen.lazyderef (tl V3611) V3695) (if (cons? V3613) (let Var (hd V3613) (let V3614 (shen.lazyderef (tl V3613) V3695) (if (cons? V3614) (let Val (hd V3614) (let V3615 (shen.lazyderef (tl V3614) V3695) (if (= () V3615) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (shen.th* Var symbol V3694 V3695 (freeze (cut Throwcontrol V3695 (freeze (shen.th* (cons value (cons Var ())) V3693 V3694 V3695 (freeze (shen.th* Val V3693 V3694 V3695 V3696)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3695) (do (shen.incinfs) (shen.t*-hyps V3694 NewHyp V3695 (freeze (shen.th* V3692 V3693 NewHyp V3695 V3696))))) (if (= Case false) (let Case (let V3616 (shen.lazyderef V3692 V3695) (if (cons? V3616) (let V3617 (shen.lazyderef (hd V3616) V3695) (if (= define V3617) (let V3618 (shen.lazyderef (tl V3616) V3695) (if (cons? V3618) (let F (hd V3618) (let X (tl V3618) (do (shen.incinfs) (cut Throwcontrol V3695 (freeze (shen.t*-def (cons define (cons F X)) V3693 V3694 V3695 V3696)))))) false)) false)) false)) (if (= Case false) (let Case (let V3619 (shen.lazyderef V3692 V3695) (if (cons? V3619) (let V3620 (shen.lazyderef (hd V3619) V3695) (if (= defmacro V3620) (let V3621 (shen.lazyderef V3693 V3695) (if (= unit V3621) (do (shen.incinfs) (cut Throwcontrol V3695 V3696)) (if (shen.pvar? V3621) (do (shen.bindv V3621 unit V3695) (let Result (do (shen.incinfs) (cut Throwcontrol V3695 V3696)) (do (shen.unbindv V3621 V3695) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3622 (shen.lazyderef V3692 V3695) (if (cons? V3622) (let V3623 (shen.lazyderef (hd V3622) V3695) (if (= shen.process-datatype V3623) (let V3624 (shen.lazyderef V3693 V3695) (if (= symbol V3624) (do (shen.incinfs) (thaw V3696)) (if (shen.pvar? V3624) (do (shen.bindv V3624 symbol V3695) (let Result (do (shen.incinfs) (thaw V3696)) (do (shen.unbindv V3624 V3695) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3625 (shen.lazyderef V3692 V3695) (if (cons? V3625) (let V3626 (shen.lazyderef (hd V3625) V3695) (if (= shen.synonyms-help V3626) (let V3627 (shen.lazyderef V3693 V3695) (if (= symbol V3627) (do (shen.incinfs) (thaw V3696)) (if (shen.pvar? V3627) (do (shen.bindv V3627 symbol V3695) (let Result (do (shen.incinfs) (thaw V3696)) (do (shen.unbindv V3627 V3695) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3695) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3695 (freeze (shen.udefs* (cons V3692 (cons : (cons V3693 ()))) V3694 Datatypes V3695 V3696))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3701 V3702 V3703 V3704) (let Case (let V3438 (shen.lazyderef V3701 V3703) (if (cons? V3438) (let V3439 (shen.lazyderef (hd V3438) V3703) (if (cons? V3439) (let V3440 (shen.lazyderef (hd V3439) V3703) (if (cons? V3440) (let V3441 (shen.lazyderef (hd V3440) V3703) (if (= cons V3441) (let V3442 (shen.lazyderef (tl V3440) V3703) (if (cons? V3442) (let X (hd V3442) (let V3443 (shen.lazyderef (tl V3442) V3703) (if (cons? V3443) (let Y (hd V3443) (let V3444 (shen.lazyderef (tl V3443) V3703) (if (= () V3444) (let V3445 (shen.lazyderef (tl V3439) V3703) (if (cons? V3445) (let V3446 (shen.lazyderef (hd V3445) V3703) (if (= : V3446) (let V3447 (shen.lazyderef (tl V3445) V3703) (if (cons? V3447) (let V3448 (shen.lazyderef (hd V3447) V3703) (if (cons? V3448) (let V3449 (shen.lazyderef (hd V3448) V3703) (if (= list V3449) (let V3450 (shen.lazyderef (tl V3448) V3703) (if (cons? V3450) (let A (hd V3450) (let V3451 (shen.lazyderef (tl V3450) V3703) (if (= () V3451) (let V3452 (shen.lazyderef (tl V3447) V3703) (if (= () V3452) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3452) (do (shen.bindv V3452 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3452 V3703) Result))) false))) (if (shen.pvar? V3451) (do (shen.bindv V3451 () V3703) (let Result (let V3453 (shen.lazyderef (tl V3447) V3703) (if (= () V3453) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3453) (do (shen.bindv V3453 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3453 V3703) Result))) false))) (do (shen.unbindv V3451 V3703) Result))) false)))) (if (shen.pvar? V3450) (let A (shen.newpv V3703) (do (shen.bindv V3450 (cons A ()) V3703) (let Result (let V3454 (shen.lazyderef (tl V3447) V3703) (if (= () V3454) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3454) (do (shen.bindv V3454 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3454 V3703) Result))) false))) (do (shen.unbindv V3450 V3703) Result)))) false))) (if (shen.pvar? V3449) (do (shen.bindv V3449 list V3703) (let Result (let V3455 (shen.lazyderef (tl V3448) V3703) (if (cons? V3455) (let A (hd V3455) (let V3456 (shen.lazyderef (tl V3455) V3703) (if (= () V3456) (let V3457 (shen.lazyderef (tl V3447) V3703) (if (= () V3457) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3457) (do (shen.bindv V3457 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3457 V3703) Result))) false))) (if (shen.pvar? V3456) (do (shen.bindv V3456 () V3703) (let Result (let V3458 (shen.lazyderef (tl V3447) V3703) (if (= () V3458) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3458) (do (shen.bindv V3458 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3458 V3703) Result))) false))) (do (shen.unbindv V3456 V3703) Result))) false)))) (if (shen.pvar? V3455) (let A (shen.newpv V3703) (do (shen.bindv V3455 (cons A ()) V3703) (let Result (let V3459 (shen.lazyderef (tl V3447) V3703) (if (= () V3459) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3459) (do (shen.bindv V3459 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3459 V3703) Result))) false))) (do (shen.unbindv V3455 V3703) Result)))) false))) (do (shen.unbindv V3449 V3703) Result))) false))) (if (shen.pvar? V3448) (let A (shen.newpv V3703) (do (shen.bindv V3448 (cons list (cons A ())) V3703) (let Result (let V3460 (shen.lazyderef (tl V3447) V3703) (if (= () V3460) (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3460) (do (shen.bindv V3460 () V3703) (let Result (let Hyp (tl V3438) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons list (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3460 V3703) Result))) false))) (do (shen.unbindv V3448 V3703) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3461 (shen.lazyderef V3701 V3703) (if (cons? V3461) (let V3462 (shen.lazyderef (hd V3461) V3703) (if (cons? V3462) (let V3463 (shen.lazyderef (hd V3462) V3703) (if (cons? V3463) (let V3464 (shen.lazyderef (hd V3463) V3703) (if (= @p V3464) (let V3465 (shen.lazyderef (tl V3463) V3703) (if (cons? V3465) (let X (hd V3465) (let V3466 (shen.lazyderef (tl V3465) V3703) (if (cons? V3466) (let Y (hd V3466) (let V3467 (shen.lazyderef (tl V3466) V3703) (if (= () V3467) (let V3468 (shen.lazyderef (tl V3462) V3703) (if (cons? V3468) (let V3469 (shen.lazyderef (hd V3468) V3703) (if (= : V3469) (let V3470 (shen.lazyderef (tl V3468) V3703) (if (cons? V3470) (let V3471 (shen.lazyderef (hd V3470) V3703) (if (cons? V3471) (let A (hd V3471) (let V3472 (shen.lazyderef (tl V3471) V3703) (if (cons? V3472) (let V3473 (shen.lazyderef (hd V3472) V3703) (if (= * V3473) (let V3474 (shen.lazyderef (tl V3472) V3703) (if (cons? V3474) (let B (hd V3474) (let V3475 (shen.lazyderef (tl V3474) V3703) (if (= () V3475) (let V3476 (shen.lazyderef (tl V3470) V3703) (if (= () V3476) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3476) (do (shen.bindv V3476 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3476 V3703) Result))) false))) (if (shen.pvar? V3475) (do (shen.bindv V3475 () V3703) (let Result (let V3477 (shen.lazyderef (tl V3470) V3703) (if (= () V3477) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3477) (do (shen.bindv V3477 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3477 V3703) Result))) false))) (do (shen.unbindv V3475 V3703) Result))) false)))) (if (shen.pvar? V3474) (let B (shen.newpv V3703) (do (shen.bindv V3474 (cons B ()) V3703) (let Result (let V3478 (shen.lazyderef (tl V3470) V3703) (if (= () V3478) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3478) (do (shen.bindv V3478 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3478 V3703) Result))) false))) (do (shen.unbindv V3474 V3703) Result)))) false))) (if (shen.pvar? V3473) (do (shen.bindv V3473 * V3703) (let Result (let V3479 (shen.lazyderef (tl V3472) V3703) (if (cons? V3479) (let B (hd V3479) (let V3480 (shen.lazyderef (tl V3479) V3703) (if (= () V3480) (let V3481 (shen.lazyderef (tl V3470) V3703) (if (= () V3481) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3481) (do (shen.bindv V3481 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3481 V3703) Result))) false))) (if (shen.pvar? V3480) (do (shen.bindv V3480 () V3703) (let Result (let V3482 (shen.lazyderef (tl V3470) V3703) (if (= () V3482) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3482) (do (shen.bindv V3482 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3482 V3703) Result))) false))) (do (shen.unbindv V3480 V3703) Result))) false)))) (if (shen.pvar? V3479) (let B (shen.newpv V3703) (do (shen.bindv V3479 (cons B ()) V3703) (let Result (let V3483 (shen.lazyderef (tl V3470) V3703) (if (= () V3483) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3483) (do (shen.bindv V3483 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3483 V3703) Result))) false))) (do (shen.unbindv V3479 V3703) Result)))) false))) (do (shen.unbindv V3473 V3703) Result))) false))) (if (shen.pvar? V3472) (let B (shen.newpv V3703) (do (shen.bindv V3472 (cons * (cons B ())) V3703) (let Result (let V3484 (shen.lazyderef (tl V3470) V3703) (if (= () V3484) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3484) (do (shen.bindv V3484 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3484 V3703) Result))) false))) (do (shen.unbindv V3472 V3703) Result)))) false)))) (if (shen.pvar? V3471) (let A (shen.newpv V3703) (let B (shen.newpv V3703) (do (shen.bindv V3471 (cons A (cons * (cons B ()))) V3703) (let Result (let V3485 (shen.lazyderef (tl V3470) V3703) (if (= () V3485) (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3485) (do (shen.bindv V3485 () V3703) (let Result (let Hyp (tl V3461) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (shen.lazyderef B V3703) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3485 V3703) Result))) false))) (do (shen.unbindv V3471 V3703) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3486 (shen.lazyderef V3701 V3703) (if (cons? V3486) (let V3487 (shen.lazyderef (hd V3486) V3703) (if (cons? V3487) (let V3488 (shen.lazyderef (hd V3487) V3703) (if (cons? V3488) (let V3489 (shen.lazyderef (hd V3488) V3703) (if (= @v V3489) (let V3490 (shen.lazyderef (tl V3488) V3703) (if (cons? V3490) (let X (hd V3490) (let V3491 (shen.lazyderef (tl V3490) V3703) (if (cons? V3491) (let Y (hd V3491) (let V3492 (shen.lazyderef (tl V3491) V3703) (if (= () V3492) (let V3493 (shen.lazyderef (tl V3487) V3703) (if (cons? V3493) (let V3494 (shen.lazyderef (hd V3493) V3703) (if (= : V3494) (let V3495 (shen.lazyderef (tl V3493) V3703) (if (cons? V3495) (let V3496 (shen.lazyderef (hd V3495) V3703) (if (cons? V3496) (let V3497 (shen.lazyderef (hd V3496) V3703) (if (= vector V3497) (let V3498 (shen.lazyderef (tl V3496) V3703) (if (cons? V3498) (let A (hd V3498) (let V3499 (shen.lazyderef (tl V3498) V3703) (if (= () V3499) (let V3500 (shen.lazyderef (tl V3495) V3703) (if (= () V3500) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3500) (do (shen.bindv V3500 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3500 V3703) Result))) false))) (if (shen.pvar? V3499) (do (shen.bindv V3499 () V3703) (let Result (let V3501 (shen.lazyderef (tl V3495) V3703) (if (= () V3501) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3501) (do (shen.bindv V3501 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3501 V3703) Result))) false))) (do (shen.unbindv V3499 V3703) Result))) false)))) (if (shen.pvar? V3498) (let A (shen.newpv V3703) (do (shen.bindv V3498 (cons A ()) V3703) (let Result (let V3502 (shen.lazyderef (tl V3495) V3703) (if (= () V3502) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3502) (do (shen.bindv V3502 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3502 V3703) Result))) false))) (do (shen.unbindv V3498 V3703) Result)))) false))) (if (shen.pvar? V3497) (do (shen.bindv V3497 vector V3703) (let Result (let V3503 (shen.lazyderef (tl V3496) V3703) (if (cons? V3503) (let A (hd V3503) (let V3504 (shen.lazyderef (tl V3503) V3703) (if (= () V3504) (let V3505 (shen.lazyderef (tl V3495) V3703) (if (= () V3505) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3505) (do (shen.bindv V3505 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3505 V3703) Result))) false))) (if (shen.pvar? V3504) (do (shen.bindv V3504 () V3703) (let Result (let V3506 (shen.lazyderef (tl V3495) V3703) (if (= () V3506) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3506) (do (shen.bindv V3506 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3506 V3703) Result))) false))) (do (shen.unbindv V3504 V3703) Result))) false)))) (if (shen.pvar? V3503) (let A (shen.newpv V3703) (do (shen.bindv V3503 (cons A ()) V3703) (let Result (let V3507 (shen.lazyderef (tl V3495) V3703) (if (= () V3507) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3507) (do (shen.bindv V3507 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3507 V3703) Result))) false))) (do (shen.unbindv V3503 V3703) Result)))) false))) (do (shen.unbindv V3497 V3703) Result))) false))) (if (shen.pvar? V3496) (let A (shen.newpv V3703) (do (shen.bindv V3496 (cons vector (cons A ())) V3703) (let Result (let V3508 (shen.lazyderef (tl V3495) V3703) (if (= () V3508) (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3508) (do (shen.bindv V3508 () V3703) (let Result (let Hyp (tl V3486) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons (shen.lazyderef A V3703) ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons (cons vector (cons (shen.lazyderef A V3703) ())) ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3508 V3703) Result))) false))) (do (shen.unbindv V3496 V3703) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3509 (shen.lazyderef V3701 V3703) (if (cons? V3509) (let V3510 (shen.lazyderef (hd V3509) V3703) (if (cons? V3510) (let V3511 (shen.lazyderef (hd V3510) V3703) (if (cons? V3511) (let V3512 (shen.lazyderef (hd V3511) V3703) (if (= @s V3512) (let V3513 (shen.lazyderef (tl V3511) V3703) (if (cons? V3513) (let X (hd V3513) (let V3514 (shen.lazyderef (tl V3513) V3703) (if (cons? V3514) (let Y (hd V3514) (let V3515 (shen.lazyderef (tl V3514) V3703) (if (= () V3515) (let V3516 (shen.lazyderef (tl V3510) V3703) (if (cons? V3516) (let V3517 (shen.lazyderef (hd V3516) V3703) (if (= : V3517) (let V3518 (shen.lazyderef (tl V3516) V3703) (if (cons? V3518) (let V3519 (shen.lazyderef (hd V3518) V3703) (if (= string V3519) (let V3520 (shen.lazyderef (tl V3518) V3703) (if (= () V3520) (let Hyp (tl V3509) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons string ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3520) (do (shen.bindv V3520 () V3703) (let Result (let Hyp (tl V3509) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons string ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3520 V3703) Result))) false))) (if (shen.pvar? V3519) (do (shen.bindv V3519 string V3703) (let Result (let V3521 (shen.lazyderef (tl V3518) V3703) (if (= () V3521) (let Hyp (tl V3509) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons string ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (if (shen.pvar? V3521) (do (shen.bindv V3521 () V3703) (let Result (let Hyp (tl V3509) (do (shen.incinfs) (bind V3702 (cons (cons (shen.lazyderef X V3703) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3703) (cons : (cons string ()))) (shen.lazyderef Hyp V3703))) V3703 V3704))) (do (shen.unbindv V3521 V3703) Result))) false))) (do (shen.unbindv V3519 V3703) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3522 (shen.lazyderef V3701 V3703) (if (cons? V3522) (let X (hd V3522) (let Hyp (tl V3522) (let NewHyps (shen.newpv V3703) (do (shen.incinfs) (bind V3702 (cons (shen.lazyderef X V3703) (shen.lazyderef NewHyps V3703)) V3703 (freeze (shen.t*-hyps Hyp NewHyps V3703 V3704))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3721 V3722 V3723 V3724) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3721 V3723)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3722 V3723) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3724))))))))) (true (thaw V3724))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3726) (cond ((and (cons? V3726) (and (cons? (tl V3726)) (and (= : (hd (tl V3726))) (and (cons? (tl (tl V3726))) (= () (tl (tl (tl V3726)))))))) (shen.prhush (shen.app (hd V3726) (cn " : " (shen.app (hd (tl (tl V3726))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3726 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3731 V3732) (cond ((= () V3731) shen.skip) ((cons? V3731) (do (shen.prhush (shen.app V3732 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3731)) (do (nl 1) (shen.show-assumptions (tl V3731) (+ V3732 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3734) (cons? (assoc V3734 (value shen.*signedfuncs*))))

(defun shen.sigf (V3736) (concat shen.type-signature-of- V3736))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3741 V3742 V3743 V3744) (let Case (let V3425 (shen.lazyderef V3742 V3743) (if (= number V3425) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3741 V3743)) V3743 V3744)) (if (shen.pvar? V3425) (do (shen.bindv V3425 number V3743) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3741 V3743)) V3743 V3744)) (do (shen.unbindv V3425 V3743) Result))) false))) (if (= Case false) (let Case (let V3426 (shen.lazyderef V3742 V3743) (if (= boolean V3426) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3741 V3743)) V3743 V3744)) (if (shen.pvar? V3426) (do (shen.bindv V3426 boolean V3743) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3741 V3743)) V3743 V3744)) (do (shen.unbindv V3426 V3743) Result))) false))) (if (= Case false) (let Case (let V3427 (shen.lazyderef V3742 V3743) (if (= string V3427) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3741 V3743)) V3743 V3744)) (if (shen.pvar? V3427) (do (shen.bindv V3427 string V3743) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3741 V3743)) V3743 V3744)) (do (shen.unbindv V3427 V3743) Result))) false))) (if (= Case false) (let Case (let V3428 (shen.lazyderef V3742 V3743) (if (= symbol V3428) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3741 V3743)) V3743 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3741 V3743))) V3743 V3744)))) (if (shen.pvar? V3428) (do (shen.bindv V3428 symbol V3743) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3741 V3743)) V3743 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3741 V3743))) V3743 V3744)))) (do (shen.unbindv V3428 V3743) Result))) false))) (if (= Case false) (let V3429 (shen.lazyderef V3741 V3743) (if (= () V3429) (let V3430 (shen.lazyderef V3742 V3743) (if (cons? V3430) (let V3431 (shen.lazyderef (hd V3430) V3743) (if (= list V3431) (let V3432 (shen.lazyderef (tl V3430) V3743) (if (cons? V3432) (let A (hd V3432) (let V3433 (shen.lazyderef (tl V3432) V3743) (if (= () V3433) (do (shen.incinfs) (thaw V3744)) (if (shen.pvar? V3433) (do (shen.bindv V3433 () V3743) (let Result (do (shen.incinfs) (thaw V3744)) (do (shen.unbindv V3433 V3743) Result))) false)))) (if (shen.pvar? V3432) (let A (shen.newpv V3743) (do (shen.bindv V3432 (cons A ()) V3743) (let Result (do (shen.incinfs) (thaw V3744)) (do (shen.unbindv V3432 V3743) Result)))) false))) (if (shen.pvar? V3431) (do (shen.bindv V3431 list V3743) (let Result (let V3434 (shen.lazyderef (tl V3430) V3743) (if (cons? V3434) (let A (hd V3434) (let V3435 (shen.lazyderef (tl V3434) V3743) (if (= () V3435) (do (shen.incinfs) (thaw V3744)) (if (shen.pvar? V3435) (do (shen.bindv V3435 () V3743) (let Result (do (shen.incinfs) (thaw V3744)) (do (shen.unbindv V3435 V3743) Result))) false)))) (if (shen.pvar? V3434) (let A (shen.newpv V3743) (do (shen.bindv V3434 (cons A ()) V3743) (let Result (do (shen.incinfs) (thaw V3744)) (do (shen.unbindv V3434 V3743) Result)))) false))) (do (shen.unbindv V3431 V3743) Result))) false))) (if (shen.pvar? V3430) (let A (shen.newpv V3743) (do (shen.bindv V3430 (cons list (cons A ())) V3743) (let Result (do (shen.incinfs) (thaw V3744)) (do (shen.unbindv V3430 V3743) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3750 V3751 V3752 V3753 V3754) (let Case (let V3416 (shen.lazyderef V3752 V3753) (if (cons? V3416) (let V3417 (shen.lazyderef (hd V3416) V3753) (if (cons? V3417) (let Y (hd V3417) (let V3418 (shen.lazyderef (tl V3417) V3753) (if (cons? V3418) (let V3419 (shen.lazyderef (hd V3418) V3753) (if (= : V3419) (let V3420 (shen.lazyderef (tl V3418) V3753) (if (cons? V3420) (let B (hd V3420) (let V3421 (shen.lazyderef (tl V3420) V3753) (if (= () V3421) (do (shen.incinfs) (identical V3750 Y V3753 (freeze (unify! V3751 B V3753 V3754)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3422 (shen.lazyderef V3752 V3753) (if (cons? V3422) (let Hyp (tl V3422) (do (shen.incinfs) (shen.by_hypothesis V3750 V3751 Hyp V3753 V3754))) false)) Case)))

(defun shen.t*-def (V3760 V3761 V3762 V3763 V3764) (let V3410 (shen.lazyderef V3760 V3763) (if (cons? V3410) (let V3411 (shen.lazyderef (hd V3410) V3763) (if (= define V3411) (let V3412 (shen.lazyderef (tl V3410) V3763) (if (cons? V3412) (let F (hd V3412) (let X (tl V3412) (let Y (shen.newpv V3763) (let E (shen.newpv V3763) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3761 V3762 V3763 V3764)))))) false)) false)) false)))

(defun shen.t*-defh (V3771 V3772 V3773 V3774 V3775 V3776) (let V3406 (shen.lazyderef V3771 V3775) (if (cons? V3406) (let Sig (hd V3406) (let Rules (tl V3406) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3772 V3773 V3774 Rules V3775 V3776)))) false)))

(defun shen.t*-defhh (V3785 V3786 V3787 V3788 V3789 V3790 V3791 V3792) (do (shen.incinfs) (shen.t*-rules V3790 V3786 1 V3787 (cons (cons V3787 (cons : (cons V3786 ()))) V3789) V3791 (freeze (shen.memo V3787 V3785 V3788 V3791 V3792)))))

(defun shen.memo (V3798 V3799 V3800 V3801 V3802) (let Jnk (shen.newpv V3801) (do (shen.incinfs) (unify! V3800 V3799 V3801 (freeze (bind Jnk (declare (shen.lazyderef V3798 V3801) (shen.lazyderef V3800 V3801)) V3801 V3802))))))

(defun shen.<sig+rules> (V3804) (let Parse_shen.<signature> (shen.<signature> V3804) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3806) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3806) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3806) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3808) (cond ((and (cons? V3808) (and (cons? (tl V3808)) (and (= () (tl (tl V3808))) (= (hd V3808) protect)))) V3808) ((cons? V3808) (map (lambda Z (shen.ue Z)) V3808)) ((variable? V3808) (concat && V3808)) (true V3808)))

(defun shen.ue-sig (V3810) (cond ((cons? V3810) (map (lambda Z (shen.ue-sig Z)) V3810)) ((variable? V3810) (concat &&& V3810)) (true V3810)))

(defun shen.ues (V3816) (cond ((shen.ue? V3816) (cons V3816 ())) ((cons? V3816) (union (shen.ues (hd V3816)) (shen.ues (tl V3816)))) (true ())))

(defun shen.ue? (V3818) (and (symbol? V3818) (shen.ue-h? (str V3818))))

(defun shen.ue-h? (V3826) (cond ((and (shen.+string? V3826) (and (= "&" (pos V3826 0)) (and (shen.+string? (tlstr V3826)) (= "&" (pos (tlstr V3826) 0))))) true) (true false)))

(defun shen.t*-rules (V3834 V3835 V3836 V3837 V3838 V3839 V3840) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3390 (shen.lazyderef V3834 V3839) (if (= () V3390) (do (shen.incinfs) (thaw V3840)) false)) (if (= Case false) (let Case (let V3391 (shen.lazyderef V3834 V3839) (if (cons? V3391) (let Rule (hd V3391) (let Rules (tl V3391) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3835 V3838 V3839 (freeze (cut Throwcontrol V3839 (freeze (shen.t*-rules Rules V3835 (+ V3836 1) V3837 V3838 V3839 V3840)))))))) false)) (if (= Case false) (let Err (shen.newpv V3839) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3836 V3839) (cn " of " (shen.app (shen.lazyderef V3837 V3839) "" shen.a)) shen.a))) V3839 V3840))) Case)) Case)))))

(defun shen.t*-rule (V3846 V3847 V3848 V3849 V3850) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3382 (shen.lazyderef V3846 V3849) (if (cons? V3382) (let Patterns (hd V3382) (let V3383 (shen.lazyderef (tl V3382) V3849) (if (cons? V3383) (let Action (hd V3383) (let V3384 (shen.lazyderef (tl V3383) V3849) (if (= () V3384) (let NewHyps (shen.newpv V3849) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3848 NewHyps V3849 (freeze (shen.t*-patterns Patterns V3847 NewHyps V3849 (freeze (cut Throwcontrol V3849 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3847) (shen.patthyps Patterns V3847 V3848) V3849 V3850))))))))) false))) false))) false)))))

(defun shen.placeholders (V3856) (cond ((shen.ue? V3856) (cons V3856 ())) ((cons? V3856) (union (shen.placeholders (hd V3856)) (shen.placeholders (tl V3856)))) (true ())))

(defun shen.newhyps (V3862 V3863 V3864 V3865 V3866) (let Case (let V3369 (shen.lazyderef V3862 V3865) (if (= () V3369) (do (shen.incinfs) (unify! V3864 V3863 V3865 V3866)) false)) (if (= Case false) (let V3370 (shen.lazyderef V3862 V3865) (if (cons? V3370) (let V3365 (hd V3370) (let Vs (tl V3370) (let V3371 (shen.lazyderef V3864 V3865) (if (cons? V3371) (let V3372 (shen.lazyderef (hd V3371) V3865) (if (cons? V3372) (let V (hd V3372) (let V3373 (shen.lazyderef (tl V3372) V3865) (if (cons? V3373) (let V3374 (shen.lazyderef (hd V3373) V3865) (if (= : V3374) (let V3375 (shen.lazyderef (tl V3373) V3865) (if (cons? V3375) (let A (hd V3375) (let V3376 (shen.lazyderef (tl V3375) V3865) (if (= () V3376) (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (if (shen.pvar? V3376) (do (shen.bindv V3376 () V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3376 V3865) Result))) false)))) (if (shen.pvar? V3375) (let A (shen.newpv V3865) (do (shen.bindv V3375 (cons A ()) V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3375 V3865) Result)))) false))) (if (shen.pvar? V3374) (do (shen.bindv V3374 : V3865) (let Result (let V3377 (shen.lazyderef (tl V3373) V3865) (if (cons? V3377) (let A (hd V3377) (let V3378 (shen.lazyderef (tl V3377) V3865) (if (= () V3378) (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (if (shen.pvar? V3378) (do (shen.bindv V3378 () V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3378 V3865) Result))) false)))) (if (shen.pvar? V3377) (let A (shen.newpv V3865) (do (shen.bindv V3377 (cons A ()) V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3377 V3865) Result)))) false))) (do (shen.unbindv V3374 V3865) Result))) false))) (if (shen.pvar? V3373) (let A (shen.newpv V3865) (do (shen.bindv V3373 (cons : (cons A ())) V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3373 V3865) Result)))) false)))) (if (shen.pvar? V3372) (let V (shen.newpv V3865) (let A (shen.newpv V3865) (do (shen.bindv V3372 (cons V (cons : (cons A ()))) V3865) (let Result (let NewHyp (tl V3371) (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866))))) (do (shen.unbindv V3372 V3865) Result))))) false))) (if (shen.pvar? V3371) (let V (shen.newpv V3865) (let A (shen.newpv V3865) (let NewHyp (shen.newpv V3865) (do (shen.bindv V3371 (cons (cons V (cons : (cons A ()))) NewHyp) V3865) (let Result (do (shen.incinfs) (unify! V V3365 V3865 (freeze (shen.newhyps Vs V3863 NewHyp V3865 V3866)))) (do (shen.unbindv V3371 V3865) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3872 V3873 V3874) (cond ((= () V3872) V3874) ((and (cons? V3872) (and (cons? V3873) (and (cons? (tl V3873)) (and (= --> (hd (tl V3873))) (and (cons? (tl (tl V3873))) (= () (tl (tl (tl V3873))))))))) (adjoin (cons (hd V3872) (cons : (cons (hd V3873) ()))) (shen.patthyps (tl V3872) (hd (tl (tl V3873))) V3874))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3881 V3882) (cond ((and (= () V3881) (and (cons? V3882) (and (= --> (hd V3882)) (and (cons? (tl V3882)) (= () (tl (tl V3882))))))) (hd (tl V3882))) ((= () V3881) V3882) ((and (cons? V3881) (and (cons? V3882) (and (cons? (tl V3882)) (and (= --> (hd (tl V3882))) (and (cons? (tl (tl V3882))) (= () (tl (tl (tl V3882))))))))) (shen.result-type (tl V3881) (hd (tl (tl V3882))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3888 V3889 V3890 V3891 V3892) (let Case (let V3357 (shen.lazyderef V3888 V3891) (if (= () V3357) (do (shen.incinfs) (thaw V3892)) false)) (if (= Case false) (let V3358 (shen.lazyderef V3888 V3891) (if (cons? V3358) (let Pattern (hd V3358) (let Patterns (tl V3358) (let V3359 (shen.lazyderef V3889 V3891) (if (cons? V3359) (let A (hd V3359) (let V3360 (shen.lazyderef (tl V3359) V3891) (if (cons? V3360) (let V3361 (shen.lazyderef (hd V3360) V3891) (if (= --> V3361) (let V3362 (shen.lazyderef (tl V3360) V3891) (if (cons? V3362) (let B (hd V3362) (let V3363 (shen.lazyderef (tl V3362) V3891) (if (= () V3363) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3890 V3891 (freeze (shen.t*-patterns Patterns B V3890 V3891 V3892)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3898 V3899 V3900 V3901 V3902) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3334 (shen.lazyderef V3898 V3901) (if (cons? V3334) (let V3335 (shen.lazyderef (hd V3334) V3901) (if (= where V3335) (let V3336 (shen.lazyderef (tl V3334) V3901) (if (cons? V3336) (let P (hd V3336) (let V3337 (shen.lazyderef (tl V3336) V3901) (if (cons? V3337) (let Action (hd V3337) (let V3338 (shen.lazyderef (tl V3337) V3901) (if (= () V3338) (do (shen.incinfs) (cut Throwcontrol V3901 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3900 V3901 (freeze (cut Throwcontrol V3901 (freeze (shen.t*-action Action V3899 (cons (cons P (cons : (cons verified ()))) V3900) V3901 V3902)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3339 (shen.lazyderef V3898 V3901) (if (cons? V3339) (let V3340 (shen.lazyderef (hd V3339) V3901) (if (= shen.choicepoint! V3340) (let V3341 (shen.lazyderef (tl V3339) V3901) (if (cons? V3341) (let V3342 (shen.lazyderef (hd V3341) V3901) (if (cons? V3342) (let V3343 (shen.lazyderef (hd V3342) V3901) (if (cons? V3343) (let V3344 (shen.lazyderef (hd V3343) V3901) (if (= fail-if V3344) (let V3345 (shen.lazyderef (tl V3343) V3901) (if (cons? V3345) (let F (hd V3345) (let V3346 (shen.lazyderef (tl V3345) V3901) (if (= () V3346) (let V3347 (shen.lazyderef (tl V3342) V3901) (if (cons? V3347) (let Action (hd V3347) (let V3348 (shen.lazyderef (tl V3347) V3901) (if (= () V3348) (let V3349 (shen.lazyderef (tl V3341) V3901) (if (= () V3349) (do (shen.incinfs) (cut Throwcontrol V3901 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3899 V3900 V3901 V3902)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3350 (shen.lazyderef V3898 V3901) (if (cons? V3350) (let V3351 (shen.lazyderef (hd V3350) V3901) (if (= shen.choicepoint! V3351) (let V3352 (shen.lazyderef (tl V3350) V3901) (if (cons? V3352) (let Action (hd V3352) (let V3353 (shen.lazyderef (tl V3352) V3901) (if (= () V3353) (do (shen.incinfs) (cut Throwcontrol V3901 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3899 V3900 V3901 V3902)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3898 (cons : (cons V3899 ()))) V3900 V3901 V3902)) Case)) Case)) Case)))))

(defun findall (V3908 V3909 V3910 V3911 V3912) (let B (shen.newpv V3911) (let A (shen.newpv V3911) (do (shen.incinfs) (bind A (gensym shen.a) V3911 (freeze (bind B (set (shen.lazyderef A V3911) ()) V3911 (freeze (shen.findallhelp V3908 V3909 V3910 A V3911 V3912)))))))))

(defun shen.findallhelp (V3919 V3920 V3921 V3922 V3923 V3924) (let Case (do (shen.incinfs) (call V3920 V3923 (freeze (shen.remember V3922 V3919 V3923 (freeze (fwhen false V3923 V3924)))))) (if (= Case false) (do (shen.incinfs) (bind V3921 (value (shen.lazyderef V3922 V3923)) V3923 V3924)) Case)))

(defun shen.remember (V3929 V3930 V3931 V3932) (let B (shen.newpv V3931) (do (shen.incinfs) (bind B (set (shen.deref V3929 V3931) (cons (shen.deref V3930 V3931) (value (shen.deref V3929 V3931)))) V3931 V3932))))



